# 卷积神经网络（CNN）入门

## CNN的结构

图像$\rightarrow$卷积层$\rightarrow$池化层$\rightarrow$全连接层$\rightarrow$输出

### 卷积层

卷积：通过对图像进行卷积运算，对图像的某个特诊进行选择性地增强或者减弱。

卷积层中使用多个过滤器对输入图像的特征进行侦测。图像的值对应的是该点的颜色。

通道数：在一般的图像数据中，每个颜色都包含RGB三种颜色。一副图像的张数称为通道数。过滤器与输入图像有相同数量的通道。

偏置：每个过滤器都对应一个偏置。

### 池化层

池化：池化层负责将图像的各个区域进行划分，并将各个区域的代表特征抽取出来，重新排列组合成一副新图像。

每个区域的最大值被作为代表此区域的值。这种池化的方法被称为最大池化。

### 全连接层

全连接层是指普通的神经网络中所使用的网络层。

卷积层和池化层的输出被传递到全连接层的输入时，图像被转化成平坦的向量。

### 填充

在卷积层和池化层中，将输入的图像包围在中心进行设置的处理方法被称为填充。

经过填充处理之后，图像的尺寸就变大了，填充的目的:确保经过卷积处理的图像大小能保持不变。卷积运算的特征决定了对图像边缘的卷积运算次数比较少，而经过填充后的边缘数据能够更多地参与卷积运算，因此进行填充能够更多地获取图像边缘的特征。

### 步长

步长：在卷积运算中，步长指过滤器每次移动的间隔距离。（步长一般设置为1）

输入图像的尺寸$I_h×I_w$，过滤器尺寸为$F_h×F_w$，填充的幅度为$D$，步长大小为$S$,则得到的输出图像的高度为$O_h$和$O_w$。

$O_h=\frac{I_h-F_h+2D}{S}+1$

$O_w=\frac{I_w-F_w+2D}{S}+1$

## CNN的学习

| 网络层  | 误差的传播 | 参与学习的参数 |
| ---- | ----- | ------- |
| 卷积层  | 是     | 过滤器，偏置  |
| 池化层  | 是     | 无       |
| 全连接层 | 是     | 权重，偏置   |

## 变量名一览表

| 变量名   | 说明      | 变量名   | 说明       |
| ----- | ------- | ----- | -------- |
| $B$   | 批次的大小   | $C$   | 输入图像的通道数 |
| $I_h$ | 输入图像的高度 | $I_w$ | 输入图像的宽度  |
| $M$   | 过滤器数量   | $F_h$ | 过滤器的高度   |
| $F_w$ | 过滤器宽度   | $O_h$ | 输出图像的高度  |
| $O_w$ | 输出图像的宽度 | $P$   | 池化区域的大小  |



## $im2col$

$im2col$:image to columns

输入的图像是一个四维数组，为$B×C×I_h×I_w$

过滤器与输入图像的通道数相同，为：$M×C×F_h×F_w$

通过$im2col$：$B×C×I_h×I_w\rightarrow CF_hF_w×BO_hO_w$

### $im2col$的算法

在卷积运算中使用$im2col$时，过滤器是在输入图像上相互重叠的区域之间滑动的，产生的矩阵的列数就是过滤器所重叠的位置的数量，与输出图像的行数$O_hO_w$相等，矩阵的行数与过滤器的像素总数$F_hF_w$相同，考虑通道数$C$,和批次尺寸$B$，得到的矩阵形状为$(CF_hF_w,BO_hO_w)$.

多个过滤器集中到一个矩阵中为$(M×CF_hF_w)$，

利用矩阵的乘法运算得到$(M,BO_hO_w)$,在进行转换成$(B,M,O_h,O_w)$

## $col2im$

将$(CF_hF_w,BO_hO_w)$转化成$(B,C,I_h,I_w)$

在卷积层，池化层的反向传播会用到。

## 卷积层

### 正向传播

* 使用$im2col$将输入图像转换成矩阵
* 将多个过滤器转换成同一个矩阵
* 对表示输入图像的矩阵和表示过滤器的矩阵进行矩阵乘法运算
* 与偏置相加
* 调整最终输出的张量形状
* 使用激励函数处理

### 反向传播

* $delta$=输出的梯度×激励函数的微分
* 过滤器的梯度=$cols$与$delta$的矩阵乘积
* 偏置的梯度=$delta$
* $cols$的梯度=$delta$与过滤器的矩阵乘积
* 输入的梯度=$col2im$（$cols$的梯度）

## 池化层

### 正向传播

* 使用$im2col$函数将输入图像转换成矩阵
* 对每个列求最大值
* 使用得到的最大值对图像进行重构，并将其作为输出数据
* 对每个列中的最大值的索引进行保存

### 反向传播

* 将输出的梯度从图像的形状转换为直线的形状
* 创建与$cols$相同尺寸的矩阵
* 将输出的梯度放入这个矩阵的每个列具有最大值的元素内
* 使用$col2im$函数将矩阵转化成图像的形状，并将其作为输入的梯度。